% vim: spell spelllang=en:
\input{preamble}

\usepackage[justification=centering]{caption}
\usepackage{subcaption}
\usepackage{graphicx}
\usepackage{enumitem}
\usepackage{lipsum}

\usepackage{siunitx}
\usepackage{hyphenat}

\usepackage{xcolor}

\definecolor{LightGray}{rgb}{0.83, 0.83, 0.83}
\definecolor{bg}{HTML}{282828}

\usepackage[newfloat]{minted}
\captionsetup[listing]{position=top}

\graphicspath{{figures/}}

\setminted{
style=monokai,
%frame=lines,
framesep=2mm,
baselinestretch=1.2,
breaklines,
bgcolor=bg,
fontsize=\footnotesize,
linenos
}

\renewcommand\theadfont{\bfseries}

\title{
    PAR Laboratory Assignment\\
    Lab 5: Geometric (data) decomposition: \\
    heat diffusion equation
}

\author{
    par2109:
    Aleix Boné,
    Alex Herrero
}

\date{
    Spring 2019-20
}

\begin{document}

\thispagestyle{empty}
\clearpage
\setcounter{page}{-1}

\begin{titlepage}
{%
    \centering
    \null{}
    \vfill
    {\Huge \bfseries PAR Laboratory Assignment\par}
    \vspace{3em}
    {\Large {\scshape Lab 5:} 
    Geometric (data) decomposition: \\
    heat diffusion equation
\par}
    \vfill
\begin{center}
\end{center}
    \vspace{3cm}

    \includegraphics{images/jacobi}

    \vfill
    {\raggedleft{} \Large
        Aleix Boné\\
        Alex Herrero\\
        {\bfseries\ttfamily par2109}\\
        \vspace{4em}
        2020-06-05 % chktex 8
        \par}
}
\end{titlepage}

\tableofcontents
\pagebreak

\section{Introduction}%
\label{sec:introduction}

In this session we are going to work on the parallelization of a sequential code that
simulates heat diffusion in a solid body using two different solvers for the heat equation.
The program reads a configuration file that specifies the maximum number of steps, the size
of the body and the solver to use which can be either \emph{Jacobi} or \emph{Gauss-Seidel}.

The two solvers have different numerical properties and behave differently when parallelized.
With the \emph{Jacobi} method, the values of the \emph{i}th iteration remain unchanged until
the next iteration has been calculated, with Gauss-Seidel the results are used immediately.
Moreover, Gauss-Seidel converges faster than Jacobi.
\footnote{\url{https://www3.nd.edu/~zxu2/acms40390F12/Lec-7.3.pdf}}.

When we tried the sequential version of the program with the input in \texttt{test.dat}
we obtained different results as shown in figure~\ref{fig:mosaic_label} and 
\emph{Gauss-Seidel} was more than twice as fast than \emph{Jacobi}:

\begin{verbatim}
Iterations        : 25000
Resolution        : 254
Algorithm         : 1 (Gauss-Seidel)
Num. Heat sources : 2
   1: (0.00, 0.00) 1.00 2.50 
   2: (0.50, 1.00) 1.00 2.50 
Time: 2.394 
Flops and Flops per second: (8.806 GFlop => 3679.06 MFlop/s)
Convergence to residual=0.000050: 12409 iterations

Iterations        : 25000
Resolution        : 254
Algorithm         : 0 (Jacobi)
Num. Heat sources : 2
   1: (0.00, 0.00) 1.00 2.50 
   2: (0.50, 1.00) 1.00 2.50 
Time: 4.819 
Flops and Flops per second: (11.182 GFlop => 2320.50 MFlop/s)
Convergence to residual=0.000050: 15756 iterations
\end{verbatim}

% Sequential heat diffusion program
% differences betweren jacobi and gauss images

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{images/mosaic_label}
    \caption{Comparison between heatmap generated by Jacobi and Gauss-Seidel}%
    \label{fig:mosaic_label}
\end{figure}

\pagebreak
\section{Analysis of task granularities and dependences with \emph{Tareador}}%
\label{sec:analysis_of_task_granularities_and_dependences_with_tareador}

% dpendency: sum on both jacobi and gauss

\begin{figure}[H]
    \begin{minipage}{0.5\textwidth}
    \centering
    \includegraphics[width=0.2\linewidth]{dependency_coarse_jacobi}
    \caption{Coarse dependency graph of Jacobi}%
    \label{fig:dependency_coarse_jacobi}
    \end{minipage}
    \begin{minipage}{0.5\textwidth}
    \centering
    \includegraphics[width=0.2\linewidth]{dependency_coarse_gauss}
    \caption{Coarse dependency graph of Gauss-Seidel}%
    \label{fig:dependency_coarse_gauss}
    \end{minipage}
\end{figure}

Figures~\ref{fig:dependency_coarse_jacobi} and \ref{fig:dependency_coarse_gauss}
show the dependency graph obtained with \emph{tareador} for Jacobi and Gauss-Seidel
respectively (with very coarse granularity).

The first thing we notice is that there are two executions of
\texttt{relax\_jacobi} and \texttt{realx\_gauss}.  Taking a look at the code
shown in listing~\ref{lst:heat_while} we can see that the program applies the
relax function on the data until the residual obtained is small enough or the
maximum number of iterations is reached. Each iteration depends on the results
of the previous one, so they cannot be parallelized. In the case ran by
\emph{tareador} this is barely noticeable since the data used is very small and
the maximum number of iterations is set 2 with a resolution of 4. However for
\texttt{test.dat} the maximum number of iterations is set to 2500 with a resolution
of 254.

In the case of Jacobi there is also the function \texttt{copy\_mat} that is
used as an auxiliary matrix, since Jacobi does not modify \texttt{u} in place
and Gauss-Seidel does.  In fact, this is the main difference between the two
algorithms, Jacobi uses the matrix from the previous iteration of the method
while Gauss-Seidel uses modifies it as it traverses the matrix.

\begin{listing}[H]
\caption{heat.c}%
\label{lst:heat_while}
\inputminted[firstline=83,lastline=104]{c}{code/heat.c}
\end{listing}

In order to further analysis the potential parallelization of both both methods,
we have to look into the inner workings of each step of the relax functions. To
achieve this, we added finer \emph{tareador} task definitions, defining tasks
for each iteration of the loops as shown in Listing~\ref{lst:solver-tar}:

\begin{listing}[H]
\caption{soler-tareador.c}%
\label{lst:solver-tar}
\inputminted[firstline=28,lastline=43]{c}{code/solver-tareador.c}
\vspace{-2.5em}
\inputminted[firstline=56,lastline=72]{c}{code/solver-tareador.c}
\end{listing}

\begin{figure}[H]
    \begin{minipage}{0.5\textwidth}
        \centering
        \includegraphics[height=6cm]{dependency_fine_jacobi.png}
        \caption{Fine dependency graph \\ Jacobi}%
        \label{fig:dependency_fine_jacobi}
    \end{minipage}
    \begin{minipage}{0.5\textwidth}
        \centering
        \includegraphics[height=6cm]{dependency_fine_gauss.png}
        \caption{Fine dependency graph \\ Gauss-Seidel}%
        \label{fig:dependency_fine_gauss}
    \end{minipage}
\end{figure}

Figure~\ref{fig:dependency_fine_jacobi} and~\ref{fig:dependency_fine_gauss} show the
task dependency graph obtained with \emph{tareador}. The results are disappointing, since
there are dependencies making all the code sequential, nevertheless, if we look at the
variables causing those dependencies (shown in figures~\ref{fig:dependence_jacobi}
and~\ref{fig:dependence_gauss}) we see that the dependence in both cases is caused by
the \texttt{sum} variable which in this case is only used once and can be reduced or
protected by an atomic clause. This means that we can still parallelize most of the
work.

However in the case of Gauss-Seidel there is another dependency corresponding to some
memory positions in the heap, which by analyzing the code we can determine that this
data on the heap is the matrix \texttt{u}. Since Gauss-Seidel modifies the data in
\texttt{u}, this creates a dependency between iterations of the method. More specifically
they have a dependency on the left cell and the top cell of the matrix.

\begin{figure}[H]
    \begin{minipage}{0.5\textwidth}
        \centering
        \includegraphics[width=0.9\linewidth]{dependence_jacobi}
        \caption{Task dependence \\ Jacobi}%
        \label{fig:dependence_jacobi}
    \end{minipage}
    \begin{minipage}{0.5\textwidth}
        \centering
        \includegraphics[width=0.9\linewidth]{dependence_gauss}
        \caption{Task dependence \\ Gauss-Seidel}%
        \label{fig:dependence_gauss}
    \end{minipage}
\end{figure}

In figure~\ref{fig:dependency_fine_jacobi_nosum} and~\ref{fig:dependency_fine_gauss_nosum}
we show the data decomposition obtained with \emph{tareador} ignoring the \texttt{sum} variable
dependency.
We can see that if we eliminate the sum dependency in Jacobi the iterations of the
loop inside \texttt{relax\_jacobi} are embarrassingly parallel. With Gauss-Seidel,
we can clearly see the top-left dependency of the iterations caused by the modification
of the matrix \texttt{u}.

\begin{figure}[H]
    \begin{minipage}{0.5\textwidth}
        \centering
        \includegraphics[height=6cm]{dependency_fine_jacobi_nosum}
        \caption{Fine dependency graph \\ Jacobi (no sum)}%
        \label{fig:dependency_fine_jacobi_nosum}
    \end{minipage}
    \begin{minipage}{0.5\textwidth}
        \centering
        \includegraphics[height=6cm]{dependency_fine_gauss_nosum}
        \caption{Fine dependency graph \\ Gauss-Seidel (no sum)}%
        \label{fig:dependency_fine_gauss_nosum}
    \end{minipage}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.3\textwidth]{heat-omp-strong-jacobi-crop}
    \caption{Strong scalability graph \\ Jacobi}%
    \label{fig:strong-jacobi}
\end{figure}

\section{Parallelization strategies}%
\label{sec:parallelization_strategies}

\section{Performance evaluation}%
\label{sec:performance_evaluation}

\section{Conclusions}%
\label{sec:conclusions}





\end{document}
